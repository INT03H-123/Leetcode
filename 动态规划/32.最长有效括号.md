### 题目描述

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

示例 1:
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
示例 2:

输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"

### 思路

题目要求是长度，所以用栈去保存括号的下标即可，不用保存括号本身；遇到左括号将其下标入栈，遇到右括号则出栈与左括号进行匹配。若栈不为空，当前右括号的下标减去栈顶元素即为以该右括号为结尾的最长有效括号的长度，若栈为空，说明当前的右括号为没有被匹配的右括号，则表示前面有效括号已结束，将该右括号的下标入栈，更新最后一个没有被匹配的右括号的下标，作为新一轮检测的标志。

### 代码

```c++
class Solution {

public:

  int longestValidParentheses(string s) 

  {

​    int n=s.size();

​    int res=0;

​    stack<int> temp;

​    temp.push(-1);

​    for(int i=0;i<n;i++)

​    {

​      if(s[i]=='(') temp.push(i);//算距离，存下标

​      else

​      {

​        temp.pop();

​        if(temp.size()==0) temp.push(i);//关键步，分隔符

​        else res=max(res,i-temp.top());

​      } 

​    }

​    return res;

}

};
```

