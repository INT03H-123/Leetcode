### 题目描述

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？
示例:
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3       2       1
    \       /      /         / \       \
     3     2     1       1   3       2
    /     /        \                        \
   2     1         2                        3

### 思路

给定一个有序序列 1⋯n，为了构建出一棵二叉搜索树，我们可以遍历每个数字 i，将该数字作为树根，将 1 ⋯(i-1) 序列作为左子树，将 (i+1)⋯n 序列作为右子树，按同样的方式递归构建左右子树。设俩个函数如下：
G（n）：长度为n的序列能构成的二叉搜索树的个数；
F（i,n）：以i为根，长度为n的序列能构成的二叉搜索树的个数（1≤i≤n）；
G（n）即为所求。
边界条件，若n=0,为空树，G（n）=1,；若n=1，该节点为根节点，无子树，G（n）=1。
由俩函数的定义可知：
![](F:\GitHub\Leetcode\动态规划\96.不同的二叉搜索树.png)

### 代码

```c++
class Solution {
public:
    int numTrees(int n) 
    {
        vector<int> G(n+1,0);
        G[0]=1,G[1]=1;
        for(int i=2;i<=n;i++)
        {
            for(int j=1;j<=i;j++)
            {
                G[i]+=G[j-1]*G[i-j];
            }
        }
        return G[n];
    }
};
```

### 算法优化

#### 分析

#### 代码

```c++

```

