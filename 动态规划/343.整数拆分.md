### 题目描述

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。

示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。

### 思路

每个正整数对应的最大乘积对应于比它小的正整数对应的最大乘积，想到动态规划。动态规划dp[i]表示正整数i拆分为至少俩个正整数的和之后，这些正整数的最大乘积，特别的0不是正整数，1是最小的正整数，不可再拆分，则有dp[0]=dp[1]=0；
当i≥2时，拆分的第一个正整数为k（1≤k<i），则有下面俩种情况：
1）将i拆分为i-k和k的和，且i-k不再进行拆分，此时的乘积为：k *（i-k）;
2）将i拆分为i-k和k的和，且i-k继续拆分为多个正整数的和，此时的乘积：k * dp[i-k]。
当k固定时，可得状态转移方程：dp[i]=max（k *（i-k）,k * dp[i-k]），k的取值范围为1---i-1，枚举k的所有取值，最终所得dp[n]即为所求。

### 代码

```c++
class Solution {
public:
    int integerBreak(int n) 
    {
        vector<int> dp(n+1,-1);
        dp[0]=0,dp[1]=0,dp[2]=1;
        for(int i=3;i<=n;i++)
        {
            for(int j=1;j<i;j++)
            {
                dp[i]=max(dp[i],max((i-j)*j,dp[i-j]*j));
            }
        }
        return dp[n];
    }
};
```

### 算法优化

#### 分析

#### 代码

```c++

```

