### 题目描述

我们正在玩一个猜数游戏，游戏规则如下：我从 1 到 n 之间选择一个数字，你来猜我选了哪个数字。每次你猜错了，我都会告诉你，我选的数字比你的大了或者小了。然而，当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。直到你猜到我选的数字，你才算赢得了这个游戏。

示例:
n = 10, 我选择了8.
第一轮: 你猜我选择的数字是5，我会告诉你，我的数字更大一些，然后你需要支付5块。
第二轮: 你猜是7，我告诉你，我的数字更大一些，你支付7块。
第三轮: 你猜是9，我告诉你，我的数字更小一些，你支付9块。
游戏结束。8 就是我选的数字。
你最终要支付 5 + 7 + 9 = 21 块钱。


给定 n ≥ 1，计算你至少需要拥有多少现金才能确保你能赢得这个游戏。

### 思路

刚开始用了二分法，结果不如意，看了大家的题解才知为何不能用二分法，理由如下：
【**为何不用二分法而采用动态规划？**】二分法只是把中间点作为分割点，在本题中即为猜的数字，而动态规划可以将每一个数当做分割点，举个例子，比如n=5：

```
动态规划：1 2 3 4 5 在第一次猜数时，我们可以猜1,2,3,4,5
二分查找：1 2 3 4 5 在第一次猜数时，我们只能猜3
```

为什么要使用动态规划猜所有的数字呢？
当n=5，假如我第一次猜3，那么需要7；假如我第一次猜4，只需要6。很显然6才是正确答案，使用二分法虽然方便，但是是错误的。所以需使用动态规划穷举所有情况。
【**动态规划思想**】动态规划dp[i] [j]表示在区间【i，j】中玩猜数字游戏，在保证一定赢得游戏的情况下，所需的最少硬币数。听着有点绕，下面举例解释一下：
(1)解释dp[1] [1]:
dp[1] [1]是指只有一个数字1，我们以1作为分割点(猜的数)，赢得游戏所用钱的最小值，一看就知道，dp[1] [1]=0。因为我们只能猜1，答案也只能是1，不用花钱

(2)解释dp[1] [2]:
dp[1] [2]是指只有两个数字1，2
我们先以1作为分割点(猜的数):
猜1：
答案是1，花费0元
答案是2，花费1元
必定赢得游戏，最多花费1元

我们再以2作为分割点(猜的数):
猜2：
答案是1，花费2元
答案是2，花费0元
必定赢得游戏，最多花费2元
综上，只要进入[1,2]这个区间，我们第一次猜1，只要花费1元，必定可以赢得游戏，所以dp[1] [2]=1(只要花1元必定赢得游戏，当第一次猜1时)。

(3)解释dp[2] [3]:
dp[2] [3]是指只有两个数字2，3
我们先以2作为分割点(猜的数):
猜2：
答案是2，花费0元
答案是3，花费2元
必定赢得游戏，最多花费2元
综上，只要进入[2,3]这个区间，我们第一次猜2，只要花费2元，必定可以赢得游戏所以dp[2] [3]=2(只要花2元必定赢得游戏，当第一次猜2时)。

(4)解释dp[1] [3]:
dp[1] [3]是指只有三个数字1，2，3
我们先以1作为分割点(猜的数):
猜1：
答案是1，花费0元
答案是2或者3，这个时候会进入另一个区间[2,3]，花费1+dp[2] [3]元
必定赢得游戏，最多花费max(0,1+dp[2] [3])元

我们再以2作为分割点(猜的数):
猜2：
答案是1，花费2+dp[1] [1]=2+0=2元
答案是2，花费0元
答案是3，花费2+dp[3] [3]=2+0=2元
必定赢得游戏，最多花费max(0,2+dp[1] [1],2+dp[3] [3])元

我们最后以3作为分割点(猜的数):
猜3：
答案是1或者2,花费3+dp[1] [2]元
答案是3，花费0元
必定赢得游戏，最多花费max(0,3+dp[1] [2])元

综上，只要进入[1] [3]这个区间，我们只要花费min( max(0,1+dp[2] [3]) , max(0,2+dp[1] [1],2+dp[3] [3]) , max(0,3+dp[1] [2]) )元必定可以赢的游戏
而dp[1] [3]也就等于那个min的值。
可以发现，只要找到dp[1] [n]即可。
【**状态转移方程**】如何写出状态转移方程，有上分析可知，要计算dp[i] [j]需要列举所有分割点的情况，我将分割点分为俩类，分别是边界分割点和中间分割点，举例说明一下，对于一个集合[i，j]：
i i+1 i+2... ... j-2 j-1 j
若选择边界为分割点，即第一次猜数为i或者j: dp1=i+dp[i+1,j]  dp2=j+dp[i,j-1];
若选择中间数为分割点，则有： dp3=k+max(dp[i] [k-1],dp[k+1] [j]) 其中   i<k<j
dp[i] [j]=max(dp1,dp2,dp3),最终答案dp[1] [n].

### 代码

```c++
class Solution {
public:
    int getMoneyAmount(int n) 
    {
        vector<vector<int>> dp(n+1,vector<int>(n+1,INT_MAX));
        for(int i=0;i<=n;i++) dp[i][i]=0;
        for(int j=2;j<=n;j++)
        {
            for(int i=j-1;i>=1;i--)
            {
                for(int k=i+1;k<=j-1;k++)
                {
                    dp[i][j]=min(k+max(dp[i][k-1],dp[k+1][j]),dp[i][j]);
                }
                dp[i][j]=min(i+dp[i+1][j],dp[i][j]);
                dp[i][j]=min(j+dp[i][j-1],dp[i][j]);
            }
        }
        return dp[1][n];
    }
};
```

### 算法优化

#### 分析

#### 代码

```c++

```

