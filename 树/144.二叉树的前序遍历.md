### 题目描述

给定一个二叉树，返回它的 前序 遍历。

示例:

输入: [1,null,2,3]  

```
  1
    \
     2
    /
   3 
```

输出: [1,2,3]

### 思路

【递归法】

递归三要素：1.递归函数的参数和返回值；2.递归终止的条件；3.确认单层递归的逻辑

**1.确定递归函数的参数和返回值**。因为要打印出中序遍历节点的数值，所以参数里需要传入vector放节点的数值，除了这一点就不需要在处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：

```cpp
void inorder(TreeNode* root,vector<int>& res)
```

**2.确定终止条件。**在递归的过程中，若当前遍历的节点为空，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：

```cpp
if(!root) return;
```

**3.确定单层递归逻辑。**前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取值，代码如下：

    res.push_back(root->val);
    inorder(root->left,res);
    inorder(root->right,res);

时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。
空间复杂度：O(n)，空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n)的级别。

### 代码

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) 
    {
        vector<int> res;
        preorder(root,res);
        return res;
    }
    void preorder(TreeNode* root,vector<int>& res)
    {
        if(!root) return;
        res.push_back(root->val);
        preorder(root->left,res);
        preorder(root->right,res);      
    }
};
```

### 算法优化或另解

#### 分析

【迭代法】

模拟递归中隐式维护的栈，代码如下：

时间复杂度：O(n)，其中 n为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。
空间复杂度：O(n)，空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。

#### 代码

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
//栈：先进后出
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) 
    {
        vector<int> res;
        stack<TreeNode*> stk;
        stk.push(root);
        while(!stk.empty())
        {
            TreeNode* temp=stk.top();
            stk.pop();
            if(temp!=NULL) res.push_back(temp->val);
            else continue;
            stk.push(temp->right);//先进后出
            stk.push(temp->left);//后进先出
        }
        return res;
    }
};
```

#### 分析

【通用迭代法】

使用栈的话，无法同时解决**处理过程和访问过程不一致**的情况，那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记，标记就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。

#### 代码

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) 
    {
        vector<int> res;
        stack<TreeNode*> stk;
        TreeNode* node=root;
        if(node!=NULL) stk.push(node);
        while(!stk.empty())
        {
            node=stk.top();
            if(node!=NULL)
            {
                stk.pop();
                if(node->right) stk.push(node->right);//右
                if(node->left) stk.push(node->left);//左
                stk.push(node);//中
                stk.push(NULL);
            }
            else{
                stk.pop();
                node=stk.top();
                stk.pop();
                res.push_back(node->val);
            }
        }
        return res;
    }
};
```

