### 题目描述

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。

```
示例:
输入: nums = [1,2,3]
输出:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

### 思路

子集是回溯类型的题目之一，注意[1,2]和[2,1]是同一个子集。

【回溯问题的解决步骤】

- 画递归树，找状态变量（回溯函数的参数）
- 确定结束条件
- 找选择列表
- 看是否剪枝
- 做选择，递归调用进入下一层
- 撤销选择

```
回溯算法模板：
int result=[];
void backtrack()
	if 满足结束条件
		result.add(选择列表,路径);
		return;
	for 选择 in 选择列表
		做选择
    	backtrack(选择列表,路径);
    	撤销选择
路径:已经做出的选择
选择列表：当前可以做的选择（涉及剪枝问题）
结束条件：已到达决策树底层，无法再做选择的条件
```

遇到回溯问题，首先画递归树，本题的递归树如下：![](D:\github\Leetcode\回溯算法or深度优先搜索\78.子集.png)

由上可知，每个数是按顺序选择的，比如，若第一个数选择了【2】，那么后面的待选则列表中只有【3】，【1】已经被排除了，所以要设置一个参数（start）来标识当前的选择列表的起始位置，也就是标识每一层的状态，也被称为状态变量。

【结束条件】本题的特殊之处在于，没有特定的结束结束条件，所有遍历的路径都应该加入结果之中，或者说当 start 参数越过数组边界的时候，程序就自己跳过下一层递归了，因此不需要手写结束条件,直接加入结果集；

【选择列表】在上面已经提到，当前选择列表是上一次选择后，剩下的在它之后的数字；

【是否剪枝】从递归树可以看到，这道题目中路径没有重复，因此不需要剪枝；

【做选择】vector就是push_back进去一个选择，然后进入下一层回溯；

【撤销选择】撤销刚刚做出的选择。

### 代码

```c++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    vector<vector<int>> subsets(vector<int>& nums) 
    {
       backtrace(nums,0);
       return res;
    }
     void backtrace(vector<int>& nums,int level)
       {
           res.push_back(path);
           for(int i=level;i<nums.size();i++)
           {
               path.push_back(nums[i]);
               backtrace(nums,i+1);
               path.pop_back();
           }
       }
};
```

### 算法优化或另解

#### 分析

#### 代码

```c++

```

