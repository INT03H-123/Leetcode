### 题目描述

一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。
骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。
有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。
为了尽快到达公主，骑士决定每次只向右或向下移动一步。
编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。

例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。
![](F:\GitHub\Leetcode\动态规划\174.地下城游戏.png)

**说明:**

- 骑士的健康点数没有上限。
- 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。

### 思路

看到这种路径的题首先想到动态规划，设动态规划为到达该点所需的最低健康值，如果从左上往右下考虑，边界条件为第1行和第一列，思考发现无法满足动态规划的【无后效性】，转变思路，从右下往左上考虑，边界条件为最后一行与最后一列，扩建一行一列用于计算边界条件，dp[row-1] [col-1]由dp[row] [col-1]和dp[row-1] [col]决定，这俩个值均为1，表示到达这俩个点的最低生命值，实则是俩个虚拟点，用于计算边界的，增加行列的其余值设为极大值，，确保最后一行（列）按照题目所给要求移动。对于其余点的计算，当前点的值为dungeon(i,j)，与之相关的两个点（下边和右边）dp[i+1] [j]和dp[i] [j+1]，他们当中的最小值是该点下一移动的位置，故该点的dp计算如下：dp[i] [j]=min(dp[i+1] [j] dp[i] [j+1] )-dungeon(i,j);注意到达该点的最小健康值要大于等于1，故最小值为1。

### 代码

```c++
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) 
    {
        if(dungeon.empty()) return 0;
        int row=dungeon.size();
        int col=dungeon[0].size();
         //到达（i，j）时所需的最低健康值
        vector<vector<int>> dp(row+1,vector<int>(col+1,INT_MAX));
        //方便计算公主位置的dp
        dp[row][col-1]=1,dp[row-1][col]=1;
        for(int i=row-1;i>=0;i--)
        {
            for(int j=col-1;j>=0;j--)
            {
                int temp=min(dp[i+1][j],dp[i][j+1]);
                //最低健康值为1
                dp[i][j]=max(temp-dungeon[i][j],1);
            }
        }
        return dp[0][0];
    }
};
```

### 算法优化

#### 分析

#### 代码

```c++

```

